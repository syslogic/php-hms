<?php
namespace HMS\PushKit;

use stdClass;

/**
 * Class HMS PushKit Uplink Message
 *
 * @see https://developer.huawei.com/consumer/en/doc/development/HMSCore-References/https-uplink-api-0000001050170915
 * @author Martin Zeitler
 */
class UpstreamMessage {

    private string|null $rawBody = null;
    private string|null $from_token = null;
    private string|null $from_package = null;
    private string|null $message_id = null;
    private string|false $message_data = false;

    /** Constructor */
    public function __construct() {
        if ( $this->parse_request_body()) {
            $this->default_response();
        }
    }

    public function getRawBody(): string|null {
        return $this->rawBody;
    }

    public function getFromToken(): string|null {
        return $this->from_token;
    }

    public function getFromPackage(): string|null {
        return $this->from_package;
    }

    public function getMessageId(): string|null {
        return $this->message_id;
    }

    public function getMessageData(): string|null {
        return $this->message_data;
    }

    /**
     * X-HW-SIGNATURE
     * Message header signature, which is mandatory, indicating the signature information sent to your server that receives uplink messages.
     *
     * timestamp=1563105451261; nonce=:; value=E4YeOsnMtHZ6592U8B9S37238E+Hwtjfrmpf8AQXF+c=
     * timestamp: standard Unix timestamp
     * nonce: colon
     * value: character string to be encrypted
     * (timestamp + nonce + Uplink message content): obtained after the encryption using the set password in HMAC-SHA256 algorithm and encoding in Base64.
     *
     * X-HW-TIMESTAMP
     *
     * @param string $from       Token of the app that sends uplink messages.
     * @param string $category   Package name of the app that sends uplink messages.
     * @param string $message_id Unique ID generated by the app for a message.
     * @param string $data       Valid key-value pairs contained in the message.
     *                           The parameter value needs to be encoded using Base64.
     */
    private function parse_request_body(): bool {
        if (isset($_SERVER['X-HW-SIGNATURE']) && !empty($_SERVER['X-HW-SIGNATURE'])) {
            $this->rawBody = stream_get_contents(STDIN);
            $secret_key = getenv('HUAWEI_UPLINK_HMAC');
            if ($this->hmac_verify( $this->rawBody, $secret_key, $_SERVER['X-HW-SIGNATURE'] )) {
                $payload = json_decode( $this->rawBody );
                $this->from_token   = $payload->from;
                $this->from_package = $payload->category;
                $this->message_id   = $payload->message_id;
                $this->message_data = base64_decode($payload->data);
                return true;
            }
        }
        return false;
    }

    /** Concatenate the input string, generate HMAC hash with SHA256 algorithm, then encode as base64. */
    private function generate_signature( int $timestamp, string $nonce, string $data_str, string $client_secret ): string {
        $input = $timestamp.$nonce.$data_str;
        $hmac = hash_hmac( 'sha256', $input, $client_secret );
        return base64_encode( $hmac );
    }

    /** Convert the received signature string to object. */
    private function to_object( string $signature ): stdClass {
        $input = str_getcsv( $signature, '; ' );
        $data = new stdClass();
        $data->timestamp = (int) str_replace('timestamp=', '', $input[0]);
        $data->nonce  = (string) str_replace(   ' nonce=', '', $input[1]);
        $data->value  = (string) str_replace(   ' value=', '', $input[2]);
        return $data;
    }

    public function hmac_verify( string $raw_body, string $client_secret, string $signature ): bool {

        /* Extract data-string from the raw body. */
        $payload = json_decode( $raw_body );
        $data_str = base64_decode( $payload->data );

        /* Convert the received signature string to object. */
        $signature = $this->to_object( $signature );

        /* Generate a signature which to compare to. */
        $generated = $this->generate_signature( $signature->timestamp, $signature->nonce, $data_str, $client_secret );

        /* Compare the generated with the received signature. */
        return $generated === $signature->value;
    }

    private function default_response() {
        die(json_encode(['errno' => 0, 'errmsg' => 'success']));
    }
}
